# Export total number of requests for all services in a site
# ArcGIS Server 10.3 or higher

# For HTTP calls
# import httplib
# import urllib
# import urllib2
import json
# For time-based functions
import time
import uuid
import datetime
import calendar
# For system tools
import sys
import os
# For reading passwords without echoing
import getpass
# For writing csv files
import csv
import configparser
import random
import requests
# urllib3 is included in requests but to manage the InsecureRequestWarning it was also imported directly
import urllib3
from urllib3.exceptions import InsecureRequestWarning
# Without disabled warnings, every request would print a red warning. This is because we have chosen
#   'verify=False' when making requests to secure services.
urllib3.disable_warnings(InsecureRequestWarning)


# Defines the entry point into the script
def main():

    # VARIABLES
    _ROOT_PROJECT_PATH = os.path.dirname(__file__)
    CREDENTIALS_PATH = os.path.join(_ROOT_PROJECT_PATH, "Docs/credentials.cfg")
    config = configparser.ConfigParser()
    config.read(filenames=CREDENTIALS_PATH)

    CSV_OUTPUT_FILE_PATH = r"D:\inetpub\wwwroot\DOIT\StatusDashboard\temp\UsageStatistics.csv"
    PASSWORD = config["ags_server_credentials"]["password"]
    SERVER_MACHINE_NAMES = {0: config['ags_prod_machine_names']["machine1"],
                            1: config['ags_prod_machine_names']["machine2"],
                            2: config['ags_prod_machine_names']["machine3"],
                            3: config['ags_prod_machine_names']["machine4"]}
    SERVER_PORT_SECURE = config['ags_prod_machine_names']["secureport"]
    SERVER_ROOT_URL = "https://{machine_name}.mdgov.maryland.gov:{port}"
    SERVER_URL_ADMIN_SERVICES = "arcgis/admin/services"
    SERVER_URL_GENERATE_TOKEN = "arcgis/admin/generateToken"
    USERNAME = config["ags_server_credentials"]["username"]

    # Ask for server name
    # serverName = "geodata.md.gov"
    # serverPort = 443

    # CLASSES

    class MachineObject:
        """Created to store machine properties and values."""
        def __init__(self, machine_name, root_url, admin_services_url, token, folders):
            """
            Instantiate the machine objects
            :param machine_name: name of the server machine
            :param root_url: root url for machine
            :param admin_services_url: root url for machine plus /arcgis/admin/services
            :param token: the token generated by the machine for secure access
            :param folders: list of folders discovered during inspection of the services
            """
            self.machine_name = machine_name
            self.root_url = root_url
            self.admin_services_url = admin_services_url
            self.token = token
            self.folders_list = folders
        def __str__(self):
            """
            Overriding the __str__ builtin to control the appearance of the machine object print-out for readability.
            :return: string
            """
            return f"{self.machine_name}-->\n\t{self.root_url}\n\t{self.services_url}\n\t{self.token}\n\t{self.folders_list}"

    class NotJSONException(Exception):
        """Raised when the url for the request is malformed for our purposes and the server returns html, not json"""
        def __init__(self):
            pass

    # FUNCTIONS
    def create_params_for_request(token_action=None):
        """
        Create parameters to be submitted with the request.
        :param token_action: route to be taken when creating the parameters
        :return: dictionary of parameters
        """
        if token_action == None:
            values = {'f': 'json'}
        elif token_action == "getToken":
            values = {'username': USERNAME, 'password': PASSWORD, 'client': 'requestip', 'f': 'json'}
        else:
            values = {'token': token_action, 'f': 'json'}
        return values

    def get_value_from_response(url, params, search_key):
        """
        Submit a request with parameters to a url and inspect the response json for the specified key of interest.
        :param url: url to which to make a request
        :param params: parameters to accompany the request
        :param search_key: the key of interest in the response json
        :return: content of json if key present in response
        """
        # To deal with mixed path characters between url syntax and os.path.join use of "\"
        url = clean_url_slashes(url)

        # FROM ORIGINAL DESIGN HANDLING CLIENT MISMATCH ERROR CONCERNING TOKEN RECOGNITION
        # To deal with the client mismatch error we were encountering, we used the following 'While' to make repeated
        #   requests as a bypass. If the error is no longer encountered because the machine name is now used to bypass
        #   the web adapter, which seemed to be connected to the issue with token mismatches, then the process will run
        #   the first time so the 'While' is removed but may be of value if similar errors arise in the future.
        # while True:

        try:
            # Jessie discovered "verify" option and set to False to bypass the ssl issue
            response = requests.post(url=url, data=params, verify=False)
        except Exception as e:
            print("Error in response from requests: {}".format(e))
            exit()
        else:
            try:
                if "html" in response.headers["Content-Type"]:
                    raise NotJSONException
                response_json = response.json()
            except json.decoder.JSONDecodeError as jde:
                print("Error decoding response to json: {}".format(jde))
                print(response)
                exit()
            except NotJSONException as NJE:
                print("Appears to be html, not json. Problem lies with ...")
                print(response.url)
                print(response.headers)
                print(response.text)
                exit()
            try:
                value = response_json[search_key]
            except KeyError as ke:
                print("KeyError: {}".format(ke))
                # continue      # for While loop usage
                exit()
            except TypeError as te:
                print("TypeError: {}".format(te))
                print(response_json)
                # continue       # for While loop usage
                exit()
            else:
                return value

    def clean_url_slashes(url):
        """
        Standardize the slashes when use of os.path.join() with forward slashes in url's.
        os.path.join() uses back slashes '\' while http uses forward slashes '/'
        :param url: url to be examined
        :return: standardized url string
        """
        url = url.replace("\\", "/")
        return url

    def create_random_int(upper_integer):
        """
        Create and return a random integer from 0 to one less than the upper range value.
        :param upper_integer: upper integer of range to be used
        :return: integer
        """
        options = upper_integer - 1
        spot = random.randint(0, options)
        return spot

    # FUNCTIONALITY
    #   Select a machine at random to which to make a request.
    machine = SERVER_MACHINE_NAMES[create_random_int(upper_integer=len(SERVER_MACHINE_NAMES))]
    print(f"MACHINE: {machine}")

    # Get a token
    root_server_url = SERVER_ROOT_URL.format(machine_name=machine, port=SERVER_PORT_SECURE)
    generate_token_url = os.path.join(root_server_url, SERVER_URL_GENERATE_TOKEN)
    token_params = create_params_for_request(token_action="getToken")
    token = get_value_from_response(url=generate_token_url, params=token_params, search_key="token")
    print(token)
    # _____________________________________________
    # token = getToken(USERNAME, PASSWORD, serverName, serverPort)
    # if token == "":
    #     print("Could not generate a token with the user name and password provided.")
    #     return
    # _____________________________________________
    #                                                                                                                       WORKING UP TO HERE


    # Get list of all services in all folders on sites
    # TODO
    #   Make a request for secure services using the token
    request_params_result = create_params_for_request(token_action=token)
    admin_services_full_url = clean_url_slashes(os.path.join(root_server_url, SERVER_URL_ADMIN_SERVICES))
    folders = get_value_from_response(url=admin_services_full_url,
                                      params=request_params_result,
                                      search_key="folders")

    #   Remove certain folders (System and Utilities per Jessie), and append entry for root folder
    # FIXME: Noticed that Jessie also included 'GeoprocessingServices' in folders to exclude. Issue?
    remove_folders = ["System", "Utilities"]
    folders = list(set(folders) - set(remove_folders))
    folders.append("")
    folders.sort()

    #   Create a machine object for the selected ArcGIS Server machine.
    machine_object = MachineObject(machine_name=machine,
                                   root_url=root_server_url,
                                   admin_services_url=admin_services_full_url,
                                   token=token,
                                   folders=folders)

    # TODO: previous functionality returned a list of all folder url's AND all service url's. Have folder names, need
    #   TODO cont...: url's. Also need all service url's
    # _____________________________________________
    # Gets a list containing all folder url's AND all service url's from within all of those folders
    services = getServiceList(serverName, serverPort, token)
    # _____________________________________________












    # Construct URL to query the logs
    # TODO
    # _____________________________________________
    statsCreateReportURL = "https://{serverName}/imap/admin/usagereports/add".format(serverName=serverName)
    # _____________________________________________


    # Create unique name for temp report
    reportName = uuid.uuid4().hex

    nowtime = datetime.datetime.utcnow()
    toTime = dt2ts(nowtime) * 1000
    fromTime = dt2ts(nowtime - datetime.timedelta(hours=48)) *1000
    print(int(toTime))
    print(int(fromTime))

    # Create report JSON definition. This json object goes into the json object submitted to the server. The object
    #   details indicate what is to be put into the report when it is built
    # TODO
    # _____________________________________________
    statsDefinition = { 'reportname' : reportName,
           'since' : 'CUSTOM',
           'from': int(fromTime),
           'to': int(toTime),
           'queries' : [{ 'resourceURIs' : services,
           'metrics' : ['RequestCount'] }],
           'aggregationInterval' : 60,                        
           'metadata' : { 'temp' : True,
           'tempTimer' : 1454109613248 } }

    # Create the json object to be posted to the server for creating the report
    postdata = {'usagereport': json.dumps(statsDefinition)}

    # Report is created on the server. No response is needed. The variable isn't used afterward for that reason.
    createReportResult = postAndLoadJSON(statsCreateReportURL, token, postdata)

    # Query the newly created report
    statsQueryReportURL = "https://{serverName}/imap/admin/usagereports/{reportName}/data".format(serverName=serverName,
                                                                                                  reportName=reportName)

    #
    postdata = {'filter': {'machines': '*'}}
    postAndLoadCSV(statsQueryReportURL, CSV_OUTPUT_FILE_PATH, token, postdata)
    
    print("Before delete")
    # Cleanup (delete) statistics report
    statsDeleteReportURL = "https://{serverName}/imap/admin/usagereports/{reportName}/delete".format(reportName=serverName,
                                                                                                     reportName=reportName)
    deleteReportResult = postAndLoadJSON(statsDeleteReportURL, token)
    
    print("Export complete!")

    return






def dt2ts(dt):
    return calendar.timegm(dt.utctimetuple())  

# A function that makes an HTTP POST request and returns the result JSON object
def postAndLoadCSV(url, fileName, token = None, postdata = None):
    """
    Appears to create a json object containing a token and format = csv, hits the url (the query report url per its
    only implementation),
    :return:
    """
    if not postdata:    # None evaluates to False
        postdata = {}

    # Add token to POST data if not already present and supplied
    if token and 'token' not in postdata:
        postdata['token'] = token

    # Add format specifier to POST data if not already present. This is where the format is set to csv.
    if 'f' not in postdata:
        postdata['f'] = 'csv'
    
    # Encode data and POST to server
    postdata = urllib.urlencode(postdata)
    response = urllib2.urlopen(url, data=postdata)

    print('post data')
    if (response.getcode() != 200):
        response.close()
        raise Exception('Error performing request to {0}'.format(url))

    # Read the response as a csv
    csvreader = csv.reader(response)

    # Open output file
    output = open(fileName, 'wb')
    csvwriter = csv.writer(output, dialect='excel')
    csvwriter.writerows(csvreader)
    output.close()  
    response.close()
    
    return


# A function that makes an HTTP POST request and returns the result JSON object
def postAndLoadJSON(url, token=None, postdata=None):
    """
    Appears to make a request to server url, includes token and format as json, and returns response as json object.
    """
    if not postdata:
        postdata = {}

    # Add token to POST data if not already present and supplied
    if token and 'token' not in postdata:
        postdata['token'] = token

    # Add JSON format specifier to POST data if not already present
    if 'f' not in postdata:
        postdata['f'] = 'json'
    
    # Encode data and POST to server
    postdata = urllib.urlencode(postdata)
    response = urllib2.urlopen(url, data=postdata)
    print('post data')

    if response.getcode() != 200:
        response.close()
        raise Exception('Error performing request to {0}'.format(url))

    data = response.read()
    response.close()
    print('postandloadjson')

    # Check that data returned is not an error object
    if not assertJsonSuccess(data):          
        raise Exception("Error returned by operation. " + data)

    # Deserialize response into Python object
    return json.loads(data)


# A function that enumerates all services in all folders on site
def getServiceList(serverName, serverPort, token):
    """
    Appears to hit the root system folder, get a list of all folder names, hit each folder url, get a list of service
    objects, and build a list of folder url's AND all service
    url's.
    TODO: Unclear why the folder url and the service urls are all in one list ?
    :return: list of folder urls AND all service urls
    """
    rooturl = "https://" + serverName + "/imap/admin/services".format(serverName, serverPort)

    # Making call to admin services url, including a token and format = json, getting back root content as json
    root = postAndLoadJSON(rooturl, token)

    # Services list will hold folder url's and exact url's to all services
    services = []

    # Accessing the folders using the 'folders' key in the root json. Is a list of folder names.
    folders = root['folders']

    # Iterating through folders
    for folderName in folders:

        # Exclude certain folders
        if folderName != "System" and folderName != "Utilities" and folderName != "GeoprocessingServices":

            # Append url for each folder of services to a list
            services.append("services/" + folderName)

            # Builds a folder url based on the imap/admin/services root
            folderurl = "{rooturl}/{folderName}".format(rooturl=rooturl, folderName=folderName)

            # Make a request to server for contents of folder and get response as json object
            folder = postAndLoadJSON(folderurl, token)

            # For each service object in the folder, append the full url for the service specific to its service type
            for service in folder['services']:
                # eg URL - https://geodata.md.gov/imap/admin/services/Agriculture/MD_AgriculturalDesignations.MapServer
                services.append("services/{folderName}/{serviceName}.{serviceType}".format(folderName=folderName,
                                                                                           serviceName=service['serviceName'],
                                                                                           serviceType=service['type']))
        
    return services
    
#A function to generate a token given username, password and the adminURL.
def getToken(username, password, serverName, serverPort):
    # Token URL is typically https://server[:port]/arcgis/admin/generateToken
    tokenURL = "/imap/admin/generateToken"

    # URL-encode the token parameters
    params = urllib.urlencode({'username': username, 'password': password, 'client': 'requestip', 'f': 'json'})
    
    headers = {"Content-type": "application/x-www-form-urlencoded", "Accept": "text/plain"}
    
    # Connect to URL and post parameters
    httpsConn = httplib.HTTPSConnection(serverName, serverPort)
    httpsConn.request("POST", tokenURL, params, headers)

    # Read response
    response = httpsConn.getresponse()
    print(response.read())
    if (response.status != 200):
        httpsConn.close()
        print("Error while fetching tokens from the admin URL. Please check the URL and try again.")
        return
    else:
        data = response.read()
        httpsConn.close()

        # Check that data returned is not an error object
        if not assertJsonSuccess(data): 
            return
        
        # Extract the token from it
        token = json.loads(data)       
        return token['token']            

#A function that checks that the input JSON object
#  is not an error object.    
def assertJsonSuccess(data):
    obj = json.loads(data)
    if 'status' in obj and obj['status'] == "error":
        print("Error: JSON object returns an error. " + str(obj))
        return False
    else:
        return True
    
        
# Script start
if __name__ == "__main__":
    main()
